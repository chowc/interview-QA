常见的限流方式有：计数器、滑动窗口、漏斗和令牌桶算法。

#### TPS

#### 令牌桶

令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。

限制加水速度，最高的水流出速度受限于桶的大小，因此可以支持桶容量的突发流量。

假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中（每秒会有r个令牌放入桶中）；

假设桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；

当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌（不同大小的数据包，消耗的令牌数量不一样），并且数据包被发送到网络；

如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外（n个字节，需要n个令牌。该数据包将被缓存或丢弃）；

算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。对于在流量限制外的数据包可以以不同的方式处理：（1）它们可以被丢弃；（2）它们可以排放在队列中以便当令牌桶中累积了足够多的令牌时再传输；（3）它们可以继续发送，但需要做特殊标记，网络过载的时候将这些特殊标记的包丢弃。

#### 漏桶算法

把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。漏桶算法的最高速率也就是限定的速度。

因为漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率。

漏桶算法与令牌桶算法的区别在于，漏桶算法能够强行限制数据的传输速率，令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。

需要注意的是，在某些情况下，漏桶算法不能够有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。

#### RateLimiter

令牌桶的实现可以简单的通过定时器，每 1/r 秒添加一个令牌到桶中，但在高并发场景下，当系统压力已经接近极限时，定时器的精度误差会非常大，同时定时器本身需要一个调度线程，也会对系统的性能产生影响。

guava 中的 RateLimiter 使用的延迟计算令牌的方式，当要获取令牌时，如果桶中有令牌则能够成功获取，如果桶中没有令牌则需要等待到下一次令牌产生时间。

假设令牌产生时间间隔为 k，当前获取令牌的时间为 now，下一个令牌产生的时间为 next，桶大小为 b，当前桶中令牌数为 n，

1. 如果 now > next，则重新计算 now-next 时间范围内能产生的令牌数，加到桶中，並重设 next 为 now；
	1. 如果计算后桶中令牌数 > 0，则成功获取到令牌；
	2. 否则需要等待 k 的时间让令牌产生，並让 next=next+k。
2. 如果 now < next，
	1. 如果此时桶中没有令牌，则等待 next-now 的时间，然后更新 next=next+k；
	2. 否则获取桶中令牌，不需要更新 next。

---
参考：
- https://blog.csdn.net/SunnyYoona/article/details/51228456
- 死锁的条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

- 什么是内存模型 Java Memory Model（JMM）

Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。

- 重排序

根据 JCIP 16.1 的说法，

> "Compilers may generate instructions in a different order than the “obvious” one suggested by the source code, or store variables in registers instead of in
memory; processors may execute instructions in parallel or out of order; caches
may vary the order in which writes to variables are committed to main memory;
and values stored in processor-local caches may not be visible to other processors.
These factors can prevent a thread from seeing the most up-to-date value for a
variable and can cause memory actions in other threads to appear to happen out
of order—if you don’t use adequate synchronization.
In a single-threaded environment, all these tricks played on our program by
the environment are hidden from us and have no effect other than to speed up
execution. The Java Language Specification requires the JVM to maintain withinthread as-if-serial semantics: as long as the program has the same result as if it
were executed in program order in a strictly sequential environment, all these
games are permissible."


只要在单线程条件下，执行的结果不发生变化，虚拟机便允许指令的重排序，以提高运行效率。

- 内存可见性

- 解释一下 happens-before 原则

Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。

happens-before 规则规定了一个操作对另一个操作的可见性，包括以下几条：

1. 程序顺序性原则

在一个线程中，按照程序执行的顺序，前面的操作 happens-before 后续的任意操作。

2. volatile 变量规则

对一个 volatile 变量的写操作，happens-before 后续对这个变量的读操作。

3. 传递性

如果 A happens-before B，B happens-before C，那么 A happens before C。

4. 管程的锁规则

对一个锁的解锁 happens-before 后续对这个锁的加锁。

5. 线程 start() 规则

主线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 happens-before 线程 B 中的任何操作。

6. 线程终止规则

一个线程运行过程的所有操作 happens-before 其它线程发现该线程已经结束，其它线程可以是通过 join() 方式发现，或者是 `Thread.isAlive()` 返回 false。

7. 中断规则

线程 A 对线程 B 调用 interrupt() happens-before 线程 B 发现自己被中断（通过抛出 InterruptedException 或者调用 isInterrupted/interrupted 方法）。

8. Finalizer 规则

一个对象构造方法的结束 happens-before 该对象 finalizer() 方法的开始。

- volatile 的意义

1. 禁用 CPU 缓存，对 volatile 变量的读写，都必须从内存中读取或者写入；
2. 禁止对 volatile 变量进行指令重排序；

- 1.5 版本之前的 volatile 缺陷

在 1.5 版本之前的 JDK，以下的单例模式是有问题的。

```java
public class Singleton {
	private volatile Singleton instance;

	public Singleton getInstance() {
		if (instance == null) {
			synchronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```
> A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable.

- [final 与可见性](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong)

被 final 修饰的属性，在*正确初始化*后，即使不进行加锁，对于所有线程都是可见的，而对于非 final 修饰的属性，即使在初始化完成后，也不能保证对所有线程的可见性。

```java
public class FinalFieldExample {
	final int x;
	int y;

	static FinalFieldExample finalFieldExample;

	public FinalFieldExample() {
		x = 4;
		y = 3;
	}

	static void writer() {
		finalFieldExample = new FinalFieldExample();
	}

	static void reader() {
		if (finalFieldExample != null) {
			// 保证看到的是 4
			int i = finalFieldExample.x;
			// 可能看到是 0。
			int j = finalFieldExample.y;
			System.out.println("x= "+i+" ,y= "+j);
		}
	}
}
```

“正确初始化”指的是在构造方法中不能够将 `this` 对象暴露：
```java
final int x;
public FinalFieldExample() { // bad!
	x = 3;
	y = 4;
	// 在构造方法还没执行完成的时候就已经暴露了 this 对象
	global.obj = this;
}
```

- synchronized 的几种用法

1. 用在类的静态方法上，表示对该类的 Class 对象进行加锁；
2. 用在类的实例方法上，表示对当前实例对象进行加锁；
3. 用在代码块上，表示对指定对象进行加锁；

- `synchronized(null)`  的后果

根据 《Java 语言规范》第九版 14.19 节，会抛出 NPE。

`synchronized ( Expression ) Block`

The type of Expression must be a reference type, or a compile-time error occurs.
A synchronized statement is executed by first evaluating the Expression.
Then:

- If evaluation of the Expression completes abruptly for some reason, then the
synchronized statement completes abruptly for the same reason.

- Otherwise, if the value of the Expression is null, a NullPointerException is
thrown.

- Otherwise, let the non-null value of the Expression be V. The executing thread
locks the monitor associated with V. Then the Block is executed, and then there
is a choice:
    
    - If execution of the Block completes normally, then the monitor is unlocked
and the synchronized statement completes normally.

    - If execution of the Block completes abruptly for any reason, then the monitor
is unlocked and the synchronized statement completes abruptly for the same
reason.

- synchronized 的实现

通过 monitors 实现，Java 中的每个对象都与一个 monitor 相关联，线程可以对 monitor 进行加锁和解锁。

1. 当 synchronized 用在代码块上时：

当前线程需要获取指定对象的 monitor 才能进入同步代码块（通过 `monitorenter` 和 `monitorexit` 指令）；

2. 当 synchronized 用在方法（静态和实例方法）上时：

编译后的文件会保留方法签名的 `synchronized`（1.8.0_131 版本），修饰符 `synchronized` 会使得方法字节码多了 `ACC_SYNCHRONIZED` 标志位，本质上仍然是通过获取和释放 monitor 来进行加锁和释放锁。

> Synchronization in the Java Virtual Machine is implemented by monitor entry and
exit, either explicitly (by use of the monitorenter and monitorexit instructions) or
implicitly (by the method invocation and return instructions).
>
> 《java virtual machine specification SE-8》3.14

> The monitorenter and monitorexit instructions are not
used in the implementation of synchronized methods, although
they can be used to provide equivalent locking semantics. Monitor
entry on invocation of a synchronized method, and monitor exit on its return, are handled implicitly by the Java Virtual Machine's
method invocation and return instructions, as if monitorenter and
monitorexit were used.
>
> 《java virtual machine specification SE-8》 6.5 monitorenter

- synchronized 与 ReentrantLock 的区别

1. synchronized 是虚拟机自身支持的（通过 monitorenter 和 monitorexit 字节码），而 ReentrantLock 是通过对 AQS 的封装实现的；
2. 两者都支持可重入，及当前持有锁的线程可以再次获取锁；
3. ReentrantLock 支持超时取消的加锁操作，且加锁操作和释放锁操作可以拆开（例如在一个方法里进行加锁，在另一个方法里释放锁）；

- synchronized collection 和 concurrent collection

synchronized 表示不允许多个线程同时进行操作，即互斥；而 Concurrent 则表示可以允许多个线程的操作同时进行。synchronized collection 会对整个对象进行加锁，因此不同线程的读和写操作需要排队，concurrent collection 例如 ConcurrentHashMap 则允许同时进行读和写操作。

- 同步集合以及并发集合

1. Collections.synchronizedMap、Collections.synchronizedList 等的实现原理；

`Map<K,V> synchronizedMap(Map<K,V> m)` 方法会接收一个 Map 对象，并返回一个线程安全的 SynchronizedMap 对象，它主要是通过包装了传入的 Map 对象，并对它的方法进行了同步，从而实现了线程安全。

`List<T> synchronizedList(List<T> list)` 同理。

2. CopyOnWriteArrayList：了解写时复制机制、了解其适用场景、思考为什么没有 ConcurrentArrayList？

通过拷贝数组来实现所有写操作（add、set 等），所以写操作的数组与之前读操作的数组是不同的对象，从而保证每次修改操作不会影响到之前的读操作（get、遍历等），同时读操作不需要进行加锁。

因为在每次写操作的时候都要进行一次拷贝，消耗较大，因此该集合适合在拼频繁进行遍历操作而写操作很少的情况下使用，另外，它也不允许通过 iterator 做写操作。

3. ConcurrentHashMap：了解实现原理、扩容时做的优化、与 HashTable 对比、ConcurrentHashMap 是如何让多线程同时参与扩容？

通过分段锁（lock strping）来提高并发。

HashTable 的线程安全是通过锁整个对象来实现的，而 ConcurrentHashMap 在读的时候不需要加锁，而且不同线程允许同时写不同的 Segment。

1.7 采用了 `Segment extends ReentrantLock` 实现分段锁，而 1.8 采用 CAS + synchronized，CAS 可以降低加锁的概率，synchronized 也只会锁定某一个 bucket，相比起 1.7 的 Segment 锁定了若干个 bucket，减少了锁竞争。

[`ConcurrentHashMap`](https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html)

节点添加到链表的头。
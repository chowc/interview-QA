- 死锁的条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

- 什么是内存模型 Java Memory Model（JMM）

Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。

- 重排序

- 内存可见性

- 解释一下 happens-before 原则

Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。

- synchronized 的几种用法

1. 用在类的静态方法上，表示对该类的 Class 对象进行加锁；
2. 用在类的实例方法上，表示对当前实例对象进行加锁；
3. 用在代码块上，表示对指定对象进行加锁；

- `synchronized(null)`  的后果

根据 《Java 语言规范》第九版 14.19 节，会抛出 NPE。

`synchronized ( Expression ) Block`

The type of Expression must be a reference type, or a compile-time error occurs.
A synchronized statement is executed by first evaluating the Expression.
Then:

- If evaluation of the Expression completes abruptly for some reason, then the
synchronized statement completes abruptly for the same reason.

- Otherwise, if the value of the Expression is null, a NullPointerException is
thrown.

- Otherwise, let the non-null value of the Expression be V. The executing thread
locks the monitor associated with V. Then the Block is executed, and then there
is a choice:
    
    - If execution of the Block completes normally, then the monitor is unlocked
and the synchronized statement completes normally.

    - If execution of the Block completes abruptly for any reason, then the monitor
is unlocked and the synchronized statement completes abruptly for the same
reason.

- synchronized 的实现

通过 monitors 实现，Java 中的每个对象都与一个 monitor 相关联，线程可以对 monitor 进行加锁和解锁。

1. 当 synchronized 用在代码块上时：

当前线程需要获取指定对象的 monitor 才能进入同步代码块（通过 `monitorenter` 和 `monitorexit` 指令）；

2. 当 synchronized 用在方法（静态和实例方法）上时：

编译后的文件会保留方法签名的 `synchronized`（1.8.0_131 版本），修饰符 `synchronized` 会使得方法字节码多了 `ACC_SYNCHRONIZED` 标志位，本质上仍然是通过获取和释放 monitor 来进行加锁和释放锁。

> Synchronization in the Java Virtual Machine is implemented by monitor entry and
exit, either explicitly (by use of the monitorenter and monitorexit instructions) or
implicitly (by the method invocation and return instructions).

> 《java virtual machine specification SE-8》3.14

- 线程安全集合

1. Collections.synchronizedMap、Collections.synchronizedList 等的实现原理；

`Map<K,V> synchronizedMap(Map<K,V> m)` 方法会接收一个 Map 对象，并返回一个线程安全的 SynchronizedMap 对象，它主要是通过包装了传入的 Map 对象，并对它的方法进行了同步，从而实现了线程安全。

`List<T> synchronizedList(List<T> list)` 同理。

2. CopyOnWriteArrayList：了解写时复制机制、了解其适用场景、思考为什么没有 ConcurrentArrayList？

3. ConcurrentHashMap：了解实现原理、扩容时做的优化、与 HashTable 对比。

[`ConcurrentHashMap`](https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html)

节点添加到链表的头。
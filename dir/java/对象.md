#### 对象

- 如何进行深拷贝？

对于值类型，在进行 = 赋值的时候，拷贝的是实际的值；对于引用类型，在进行 = 赋值的时候，拷贝的是对象的引用。因此为了实现深拷贝，需要对对象中所有引用类型的属性都依次进行深拷贝。

方法一，[通过序列化](http://javatechniques.com/blog/faster-deep-copies-of-java-objects/)

先对对象进行序列化，然后再将其反序列化，因为在反序列化的过程中会创建一个新的对象，从而实现了深拷贝。（要保证该对象允许被序列化，同时对象中的属性也允许被序列化，以及反序列化方法没有被 override 为不进行对象创建。）

代码如下：
```java
public static Object copy(Object orig) {
    Object obj = null;
    try {
        // Write the object out to a byte array
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(bos);
        out.writeObject(orig);
        out.flush();
        out.close();

        // Make an input stream from the byte array and read
        // a copy of the object back in.
        ObjectInputStream in = new ObjectInputStream(
            new ByteArrayInputStream(bos.toByteArray()));
        obj = in.readObject();
    }
    catch(IOException e) {
        e.printStackTrace();
    }
    catch(ClassNotFoundException cnfe) {
        cnfe.printStackTrace();
    }
    return obj;
}
```

==待补充：序列化机制==

方法二，实现自己的 `deepCopy` 方法，并对引用树进行递归拷贝（recursing through the entire graph of other objects referenced by the object being copied），这个方法有以下限制：

    1. 被修改的类必须能够新增方法或继承新的父类；
    2. 被修改类必须能够访问到父类的所有属性；
    3. 对于所有遍历到的引用类型，都必须保证能够对它们进行拷贝。

- Java 序列化的方式

1. [Serializable](https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf)：实现 `java.io.Serializable` 接口，然后可以通过 `ObjectOutputStream`、`ObjectInputStream` 来对对象进行序列化和反序列化。

通过重写 writeObject 与 readObject 方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果 writeObject 使用某种规则序列化，则相应的 readObject 需要相反的规则反序列化，以便能正确反序列化出对象。

writeReplace：在序列化时，会先调用此方法，再调用 writeObject 方法。此方法可将任意对象代替目标序列化对象。

readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在 readeObject 后调用。**readResolve 常用来反序列单例类，保证单例类的唯一性。**

对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient 实例变量都不会被序列化。

优点：java 原生支持，不需要提供第三方的类库，使用比较简单。

缺点：无法跨语言，字节数占用比较大，某些情况下对于对象属性的变化比较敏感。

对象在进行序列化和反序列化的时候，必须实现 Serializable 接口，但并不强制声明唯一的 serialVersionUID。是否声明 serialVersionUID 对于对象序列化的向上向下的兼容性有很大的影响。

2. 实现 Externalizable 接口

需要实现 `writeExternal`、`readExternal` 方法，用于控制属性的序列化。另外必须提供 pulic 的无参构造器，因为在反序列化的时候需要反射创建对象。

2. JSON：通过例如 jackson/fastjson/gson 将对象序列化为 JSON 字符串；

优点：明文结构一目了然，可以跨语言，属性的增加减少对解析端影响较小。

缺点：字节数过多，依赖于不同的第三方类库。

3. ProtoBuf

优点：字节数很小，适合网络传输，跨语言 。

缺点：需要依赖于工具生成代码。

- 为什么说不建议使用 `Object.clone()` 实现深拷贝？

参见《Effective Java》第十一条。


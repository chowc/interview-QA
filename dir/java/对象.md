### 对象

#### 如何进行深拷贝？

对于值类型，在进行 = 赋值的时候，拷贝的是实际的值；对于引用类型，在进行 = 赋值的时候，拷贝的是对象的引用。因此为了实现深拷贝，需要对对象中所有引用类型的属性都依次进行深拷贝。

方法一，[通过序列化](http://javatechniques.com/blog/faster-deep-copies-of-java-objects/)

先对对象进行序列化，然后再将其反序列化，因为在反序列化的过程中会创建一个新的对象，从而实现了深拷贝。（要保证该对象允许被序列化，同时对象中的属性也允许被序列化，以及反序列化方法没有被 override 为不进行对象创建。）

代码如下：
```java
public static Object copy(Object orig) {
    Object obj = null;
    try {
        // Write the object out to a byte array
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(bos);
        out.writeObject(orig);
        out.flush();
        out.close();

        // Make an input stream from the byte array and read
        // a copy of the object back in.
        ObjectInputStream in = new ObjectInputStream(
            new ByteArrayInputStream(bos.toByteArray()));
        obj = in.readObject();
    }
    catch(IOException e) {
        e.printStackTrace();
    }
    catch(ClassNotFoundException cnfe) {
        cnfe.printStackTrace();
    }
    return obj;
}
```

==待补充：序列化机制==

方法二，实现自己的 `deepCopy` 方法，并对引用树进行递归拷贝（recursing through the entire graph of other objects referenced by the object being copied），这个方法有以下限制：

    1. 被修改的类必须能够新增方法或继承新的父类；
    2. 被修改类必须能够访问到父类的所有属性；
    3. 对于所有遍历到的引用类型，都必须保证能够对它们进行拷贝。


#### 为什么说不建议使用 `Object.clone()` 实现深拷贝？

参见《Effective Java》第十一条。
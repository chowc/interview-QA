#### 主流消息中间件的比较

---
### RabbitMQ

#### 发送方消息确认

默认情况下发生消息的操作时不会返回任何消息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前已经丢失，持久化操作也解决不了这个问题。

RabbitMQ 提供了两种解决方式：

1. 通过事务机制实现
2. 通过发送方确认（publisher confirm）机制实现

- 事务机制

事务机制在一条消息发送之后会使发送方阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。
**使用事务机制会严重降低 RabbitMQ 的消息吞吐量。**

- 发送方确认机制

生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的 ID（从 1 开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（`Basci.ACK`）给生产者（包含消息的唯一 ID），这就使得生产者知晓消息已经正确地到达了目的地了。

发送方确认的优势在于并不一定需要同步确认，可以有以下两种确认方式：

    1. 批量确认：每发送一批消息后，调用 `channel.waitForConfirms` 方法，等待服务器的确认返回（此时是阻塞的）；
    2. 异步确认：提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法进行处理。

对于批量确认，如果出现返回 `Basic.Nack` 或者超时情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且当消息经常丢失时，批量确认的性能是不升反降的。

#### 消费确认

消费者客户端可以通过推或者拉模式的方式来获取并消费消息，当消费者处理完业务逻辑需要手动确认消息已被接收，这样 RabbitMQ 才能把当前消息从队列中清除。如果消费者由于某些原因无法处理当前接收到的消息，可以通过 `channel.basciNack` 或者 `channel.basicReject` 来拒绝掉。
#### 主流消息中间件的比较

---
### RabbitMQ

#### 基本概念

基本概念: virtual host，exchange，queue，binding，binding key，routing key

![image](rabbitmq_msgsend.png)

- exchange 交换机类型

1. fanout
2. direct
3. topic
4. headers

- Connection、channel

> 一个 Connection 代表到 MQ 服务器的一条 TCP 连接，一旦 TCP 连接建立起来，客户端紧接着可以创建一个 AMQP 信道 (Channel) ，每个信道都会被指派一个唯一的 ID。信道是建立在 Connection 之上的虚拟连接， RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。
>
> 我们完全可以直接使用 Connection 就能完成信道的工作，为什么还要引入信道呢?试想这样一个场景， 一个应用程序中有很多个线程需要从 RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个 Connection，也就是许多个 TCP 连接。然而对于操作系统而言，建立和销毁 TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。 RabbitMQ 采用类似 NIO 的做法，选择 TCP 连接复用，不仅可以减少性能开销，同时也便于管理。
>
> *每个线程把持一个信道*（channel 不是线程安全的，即使某些方法是线程安全的，即多个线程共用一个 channel 的话需要进行额外加锁，所以一般推荐对一个 channel 建立一个线程，一个 channel 就代表了一个消息的消费者），所以信道复用了 Connection 的 TCP 连接。同时 RabbitMQ 可以确保每个线程的私密性，就像拥有独立的连接一样。当每个信道的流量不是很大时，复用单一的 Connection 可以在产生性能瓶颈的情况下有效地节省 TCP 连接资源。但是当信道本身的流量很大时，这时候多个信道复用一个 Connection 就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个 Connection，将这些信道均摊到这些 Connection 中。

- `channel.basicConsume` 是客户端拉取还是 MQ 服务器的推送？

消费的两种模式：推和拉

> Basic.Consume 将信道 (Channel) 直为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 Basic.Qos 的限制.如果只想从队列获得单条消息而不是持续订阅，建议还是使用 Basic.Get 进行消费.但是不能将 Basic.Get 放在一个循环里来代替 Basic.Consume ，这样做会严重影响 RabbitMQ 的性能.如果要实现高吞吐量，消费者理应使用 Basic.Consume 方法。

#### 发送方消息确认

默认情况下发生消息的操作时不会返回任何消息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前已经丢失，持久化操作也解决不了这个问题。

RabbitMQ 提供了两种解决方式：

1. 通过事务机制实现
2. 通过发送方确认（publisher confirm）机制实现

- 事务机制

事务机制在一条消息发送之后会使发送方阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。
**使用事务机制会严重降低 RabbitMQ 的消息吞吐量。**

- 发送方确认机制

生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的 ID（从 1 开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（`Basci.ACK`）给生产者（包含消息的唯一 ID），这就使得生产者知晓消息已经正确地到达了目的地了。

发送方确认的优势在于并不一定需要同步确认，可以有以下两种确认方式：

    1. 批量确认：每发送一批消息后，调用 `channel.waitForConfirms` 方法，等待服务器的确认返回（此时是阻塞的）；
    2. 异步确认：提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法进行处理。

对于批量确认，如果出现返回 `Basic.Nack` 或者超时情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且当消息经常丢失时，批量确认的性能是不升反降的。

#### 消费确认

消费者客户端可以通过推或者拉模式的方式来获取并消费消息，当消费者处理完业务逻辑需要手动确认消息已被接收，这样 RabbitMQ 才能把当前消息从队列中清除。如果消费者由于某些原因无法处理当前接收到的消息，可以通过 `channel.basciNack` 或者 `channel.basicReject` 来拒绝掉。

#### 死信

- 消息变成死信的原因：

    1. 消息被拒绝（`Basic.Reject/Basic.Nack`），并且设置 requeue 参数为 false；
    2. 消息过期；
    3. 队列达到最大长度。
    
- 采用死信队列做延时队列

死信交换器（Dead-Letter-Exchange，DLX）也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动将这个消息重新发布到设置的 DLX 上去，进而被路由到另一个队列，即死信队列。

假设一个应用中需要将每条消息都设置为 10 秒的延迟，生产者通过 `exchange.normal` 这个交换器将发生的消息存储在 `queue.normal` 这个队列中。消费者订阅的并非是 `queue.normal` 这个队列，而是 `queue.dlx` 这个队列。当消息从 `queue.normal` 这个队列中过期之后被存入 `queue.dlx` 队列中，消费者就恰巧消费到了延迟 10 秒的这条消息。

---
- 参考资料

1. 《RabbitMQ 实战指南》
http://www.dengshenyu.com/java/分布式系统/2017/10/23/zookeeper-distributed-lock.html

- 客户端对ServerList的轮询机制是什么

> 随机，客户端在初始化 `(new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher))` 的过程中，将所有 Server 保存在一个 List 中，然后随机打散，形成一个环。之后从 0 号位开始一个一个使用。

两个注意点：
1. Server 地址能够重复配置，这样能够弥补客户端无法设置 Server 权重的缺陷，但是也会加大风险。（比如: 192.168.1.1:2181,192.168.1.1:2181,192.168.1.2:2181)；
2. 如果客户端在进行 Server 切换过程中耗时过长，那么将会收到 SESSION_EXPIRED. 这也是上面第 1 点中的加大风险之处。


客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。


### ZAB 协议

ZAB 协议的三个阶段：

1. 发现（即选举）；
2. 同步（选出Leader后，Follower和Observer需进行数据同步）；
3. 广播（同步之后，集群对外工作响应请求，并进行消息广播，实现数据在集群节点的副本存储）。

#### 选举

- 发生的时机

1. 服务器初始化启动；
2. 服务器运行期间无法连接到 Leader：Leader 挂了或发生网络故障（Leader 与过半节点心跳中断）。

- 选举的条件

至少需要 2 个节点，才能保证投票可以得到过半数。

- 选举的过程：FastLeaderElection

假设当前集群有 2 个节点：Server1、2。

(1) 每个 Server 发出一个投票。由于是初始情况，Server1 和 Server2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的 serverId（配置在各个节点的配置文件中，每个节点拥有所有节点的 serverId，且各个节点不能相同）和 zxId，使用 (serverId, zxId) 来表示，此时 Server1 的投票为 (1, 0)，Server2 的投票为 (2, 0)，然后*各自*将这个投票发给集群中其他机器；

(2) 每个节点接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（选举轮次=>逻辑时钟=>每次选举递增）、是否来自 LOOKING 状态的服务器（只有 LOOKING 状态的节点可以进行选举）：
	1. 如果选举轮次不同：
		1. 如果接受到的选举轮次小于自己：忽略接受到的投票；
		2. 如果接受到的选举轮次大于自己：将自己的选举轮次更新，清空选票，並进行 PK；
	2. 选举轮次相同：进行 PK；

(3) 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行 PK，PK 规则如下：

	1. 优先检查 zxId。zxId 比较大的服务器优先作为 Leader：zxId 越大，其数据越新；
	2. 如果 zxId 相同，那么就比较 serverId。serverId 较大的服务器作为 Leader 服务器。

对于 Server1 而言，它的投票是 (1, 0)，接收 Server2 的投票为 (2, 0)，首先会比较两者的 zxId，均为 0，再比较 serverId，此时 Server2 的 serverId 最大，于是更新自己的投票为(2, 0)，然后重新投票，对于 Server2 而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可；

zxid 由两部分构成：主进程周期 epoch 和事务单调递增的计数器。zxid 是一个 64 位的数，高 32 位代表主进程周期 epoch，低 32 位代表事务单调递增的计数器。

主进程周期 epoch 也叫 epoch，是选举的轮次，每选举一次就递增。*事务单调递增的计数器在每次选举完成之后就会从 0 开始*。

如果是比较数据新旧的话，直接比较就可以了。因为如果是主进程周期越大，即高 32 位越大，那么低 32 位就不用再看了。如果主进程周期一致，低 32 位越大，整个 zxid 就越大。所以直接比较整个 64 位就可以了，不必高 32 位于高 32 位对比，低 32 位与低 32 位比较。

(4) 统计投票。每次投票后，服务器都会统计投票信息，判断*是否已经有过半机器接受到相同的投票信息*，对于 Server1、Server2 而言，都统计出集群中已经有两台机器接受了 (2, 0) 的投票信息，此时便认为已经选出了 Leader；

(5) 改变服务器状态。一旦确定了 Leader，每个服务器就会更新自己的状态，如果是 Follower，那么就变更为 FOLLOWING，如果是 Leader，就变更为 LEADING。

此时如果有新的节点 Server3 加入集群，会被告知当前的 Leader。

当在运行期间，无法连接到 Leader 时，其他节点会将自己的状态改为 LOOKING，然后发起新一轮的选举，选举轮次自增。

- 节点角色及状态

1. Leader

事务请求的唯一调度和处理者，保证集群事务处理的顺序序性，集群内部各服务器的调度者。

2. Follower
	1. 处理客户端非事务请求，转发事务请求给 Leader 服务器；
	2. 参与事务请求 Proposal 的投票；
	3. 参与 Leader 的选举投票。
3. Observer
	1. 处理客户端非事务请求，转发事务请求给 Leader 服务器；
	2. 不参加任何形式的投票，包括选举和事务投票；
	3. Observer 的存在是为了提高 zk 集群对外提供读性能的能力。

1. LOOKING：寻找 Leader，在选举过程中；
2. LEADING：当前是 Leader；
3. FOLLOWING：当前是 Follower；
4. OBSERVING：当前是 Observer。

- 事务请求和非事务请求

事务请求是进行数据修改的请求，都要由 Leader 节点进行处理，非 Leader 节点接受到事务请求则转发给 Leader 进行处理。

非事务请求则是读请求。

- Leader 可以处理非事务请求吗？
- zk 的 3 个端口：
```
#conf/zoo.cfg
tickTime=2000
dataDir=/home/zookeeper/data
dataLogDir=/home/zookeeper/log
clientPort=2181
initLimit=5
syncLimit=2
server.1=192.168.1.1:2888:3888
server.2=192.168.1.2:2888:3888
server.3=192.168.1.3:2888:3888
```
1. 客户端连接端口：默认 2181；
2. 通信和数据同步端口：默认 2888，当选举出 Leader 后，Follower 会创建一个到 Leader 的 2888 端口的 TCP 连接；
3. 投票端口：默认 3888。

- 投票时的连接

> 为了能够进行互相投票，zk 集群中的所有机器都需要两两建立起网络连接。QuorumCnxManager 在启动的时候，会创建一个 ServerSocket 来监听 Leader 选举的通信端口（Leader 选举的通信端默认是 3888）。开启端口监听后，zk 就能够不断地接收到来自其他服务器的“创建连接”请求，在接收到其他服务器的 TCP 连接请求时，**为了避免两台机器之间重复地创建 TCP 连接，zk 设计了一种建立 TCP 连接的规则：只允许 SID 大的服务器主动和其他服务器建立连接，否则断开连接。服务器通过对比自己和远程服务器的 SID 值，来判断是否接受连接请求。如果当前服务器发现自己的 SID 值更大，那么会断开当前连接，然后自己主动去和远程服务器建立连接。**

- 创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？

连接断了之后，ZK不会马上移除临时数据，只有当SESSIONEXPIRED之后，才会把这个会话建立的临时数据移除。因此，用户需要谨慎设置Session_TimeOut。

- zk 集群如何动态扩容？
- ZK集群如何实现高可用部署？
#### 同步

#### 广播
---
参考资料：
- http://jm.taobao.org/2013/10/07/zookeeper-faq/
- https://www.jianshu.com/p/57fecbe70540
- https://www.cnblogs.com/longxok/p/8951867.html
### TCP

- TCP、UDP 的区别

1. TCP 面向连接（如打电话要先拨号建立连接）；UDP 是无连接的，即发送数据之前不需要建立连接；
2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保   证可靠交付；
3. TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP是面向报文的；
4. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；
4. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信；
5. TCP 首部开销 20 字节；UDP 的首部开销小，只有8个字节；
6. TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。

- UDP应用场景：

1. 面向数据报方式；
2. 网络数据大多为短消息；
3. 拥有大量 client；
4. 对数据安全性无特殊要求；
5. 网络负担非常重，但对响应速度要求高；

- [三次握手、四次挥手的过程](https://blog.csdn.net/lengxiao1993/article/details/82771768)

![image](img/tcp.png)

需要注意的是，上图中出现的 ACK=x+1 的写法很容易让人误以为数据包中的 ACK 域的数据值被填成了 y+1。ACK=x+1 的实际含义是：

1. TCP 包的 ACK 标志位（1 bit） 被置成了 1；
2. TCP 包的确认号（acknowledgement number ） 的值为 x+1。

- 半连接攻击

三次握手中，在第一步 server 收到 client 的 syn 后，把相关信息放到半连接队列中，同时回复 syn+ack 给 client（第二步）。半连接攻击是针对半连接队列的，攻击方不停地建连接，但是建连接的时候只做第一步，第二步中攻击方收到 server 的 syn+ack 后故意扔掉什么也不做，导致 server 上这个队列满其它正常请求无法进来。

服务器发送完 syn+ack 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。

- 为什么 TCP 需要握手环节？

TCP 协议为了实现可靠传输，通信双方需要判断自己已经发送的数据包是否都被接收方收到，如果没收到，就需要重发。为了实现这个需求，很自然地就会引出序号（sequence number）和确认号（acknowledgement number）的使用。而握手环节就是为了交换序号和确认号的。

- 为什么需要第三次握手？

1. 为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；
2. 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

- TCP 如何实现可靠传输？

1. 确认机制；
2. 超时重传；
3. 数据校验；
4. 数据合理分片和排序：

　　UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.

　　tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。

5. 流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失，根据接收端返回的缓冲窗口大小决定；

	1. 发送窗口：当前允许发送的数据区间，区间之间的数据是已经确认的，发送方的发送窗口，不能超过接收方给出的接受窗口的数值；
	2. 接收窗口：当前允许接收的数据区间，区间之前的数据是已经确认的；

接收方将自己可接受的缓冲区大小放入TCP首部中的”窗口大小字段”，通过ACK通知发送端；窗口大小字段越大，说明网络的吞吐量越高；接收方一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值给发送端；发送端接受到这个窗口之后，就会减慢自己的发送速率；如果接受缓冲区满了，就会将窗口设置为0，这时发送方不在发送数据，但是需要定期发送一个窗口探测数据段，使接收方把窗口大小告诉发送端。


6. 拥塞控制：当网络拥塞时，减少数据的发送，通过 ACK 是否丢失导致重传来决定。

发送窗口大小 = min(发送窗口大小, 拥塞窗口大小)

	1. 慢开始：刚开始时，定义拥塞窗口的大小为 1，每次接收到一个 ACK 应答，拥塞窗口值 *2，每次发送数据包的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，取较小的值作为实际发送的窗口。这样的拥塞窗口增长的速度是指数级别的，慢启动只是指初始时慢，但是增长速度很快。
	2. 拥塞避免：引入一个慢启动的阈值，当拥塞窗口超过这个阈值的时候，不在按指数方式增长，而是按照线性方式增长。
	3. 快重传
	4. 快恢复

- 超时重传时间如何确定？

TCP 采用了一种自适应算法，它记录一个报文发出的时间，以及收到相应确认的时间，或者两个时间之差就是报文的往返时间 RTT。
最理想的情况下，找到一个最小的时间，保证确认应答一定能在这个时间内返回。

Linux 中，超时以 500ms 为一个单位进行控制，每次判定超时重发的超时时间都是 500ms 的整数倍；如果重发一次仍然得不到应答，等待 2*500ms 后再进行重传；如果仍然得不到应答，等待 4*500ms 进行重传，依次类推，以指数形式递增；累积到一定的重传次数，TCP 认为网络或者对端主机出现异常，强制关闭连接。

---
### HTTP、HTTPS
- 浏览器访问一个网页的过程



- [HTTPS 如何建立连接？](https://juejin.im/post/5a4f4884518825732b19a3ce)

![image](img/https.png)

- [HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？](https://zhuanlan.zhihu.com/p/43789231)

显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就行。

服务器会为每个浏览器（或客户端软件）维护一个 session ID，在 TSL 握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的 session ID 下，之后浏览器每次请求都会携带 session ID，服务器会根据 session ID 找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。

- HTTP keep-alive 与 tcp keep-alive
- HTTP 中 transfer-encoding 头部](https://imququ.com/post/transfer-encoding-header-in-http.html)

针对服务端有时候不能确定响应的 content-length，而又要降低 TTFB（Time To First Byte，它代表的是从客户端发出请求到收到响应的第一个字节所花费的时间），可以使用 transfer-encoding 来使用分块编码。
